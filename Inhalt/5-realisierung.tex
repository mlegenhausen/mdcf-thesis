\chapter{Realisierung}
\label{cha:realisierung}
In diesem Kapitel wird die aus dem Konzept entwickelte Realisierung beschrieben.
Die Anwendung trägt dabei den Arbeitstitel {\em Mobile Data Collector}, während
das Framework zur Erstellung von Plug-Ins den Namen {\em Mobile Data Collection
Framework} trägt.

Der {\em Mobile Data Collector} wird als Open Source Projekt entwickelt und kann
entweder von der beiliegenden CD oder von Github unter der Adresse
\url{https://github.com/mlegenhausen/mdcf} bezogen werden. Das Projekt ist dabei
in die folgenden Teile gegliedert:

\begin{itemize}
  \item {\bf MobileDataCollector}: Die {\em Mobile Data Collector} Android
  Anwendung.
  \item {\bf MobileDataCollectionFramework}: Das Framework zur Entwicklung von
  Plug-Ins.
  \item {\bf LocationTrackerPlugin}: Ein Beispiel Plug-In zum Sammeln von
  Standortdaten.
  \item {\bf NoiseTrackerPlugin}: Eine Erweiterung des {\em
  LoationTrackerPlugin}, bei dem neben der aktuellen Position, auch die
  Lautstärke gespeichert wird.
  \item {\bf mdcf-remote}: Framework zur Entwicklung der Serverkomponente.
  \item {\bf mdcf-locationtracker-remote}: Eine Beispielserverkomponente für
  das {\em LocationTrackerPlugin}.
  \item {\bf mdcf-noisetracker-remote}: Eine Beispielserverkomponente für das
  {\em NoiseTrackerPlugin}.
\end{itemize}

\section{Architektur des Mobile Data Collection Frameworks}
Das {\em Mobile Data Collection Framework} dient zur Erstellung von Plug-Ins. Es
beinhaltet alle Klassen und Schnittstellen, die zwischen dem {\em Mobile Data
Collector} und dem Plug-In geteilt werden, um eine Kommunikation zwischen beiden
Komponenten zu ermöglichen. Das Framework wird als Android Bibliothek zur
Verfügung gestellt.

Das Framework ist in drei Teile gegliedert. Zum einen Klassen und Interfaces,
die es einem Plug-In erlauben sich an dem Plug-In System anzumelden und mit
diesem zu kommunizieren. Zum anderen einer Implementierung der in Abschnitt
\ref{unifiedrepresentation} beschriebenen Datenstruktur sowie der in Abschnitt
\ref{securepluginexecution} beschriebenen sicheren Android Services.

Ein Plug-In wird dadurch definiert, dass es die {\em Plugin}-Schnittstelle
implementiert. Diese stellt alle für das Plug-In System nötigen Methoden
zur Verfügung, um mit dem Plug-In zu interagieren. Die Schnittstelle selbst
besteht aus einer Reihe von {\em Settern}, mit denen die sicheren Versionen der
Android System Services und der {\em PersistenceManager} gesetzt werden, sowie
einer {\em run}-Methode, mit der das Plug-In ausgeführt wird. Auf Folgende
sichere Versionen der Android System Services kann ein Plug-In zugreifen:

\begin{itemize}
  \item {\bf ConnectivityManager}: Erlaubt den Zugriff, auf aktuelle
  Netzwerkinformationen, auf die der Benutzer zugreifen kann.
  \item {\bf LocationManager}: Erlaubt den Zugriff auf, Methoden zur
  Positionsbestimmung des Benutzers.
  \item {\bf TelephonyManager}: Erlaubt den Zugriff auf Telefonfunktionalitäten.
  \item {\bf WifiManager}: Erlaubt das Auffinden und den Zugriff auf
  \acsp{wlan}.
\end{itemize}

Da die {\em Setter}-Implementierungen trivial und in den meisten Fällen
identisch sind, gibt es zur Vereinfachung die Klasse {\em AbstractPlugin}. Erbt
man von dieser Klasse, muss nur noch eine vereinfachte Version der {\em
run}-Methode, die {\em onRun}-Methode implementiert werden.

Innerhalb der {\em run}- bzw. {\em onRun}-Methode kann auf die gesetzten
Services zugegriffen werden. Die Services bieten alle in der Android Dokumentation beschriebenen
Methoden. Neben den Services kann auch auf einen {\em PersistenceManager}
zugegriffen werden. Dieser erlaubt über die {\em getWorkspace}-Methode den
einfachen Zugriff auf alle bisher gespeicherten Daten. Die zurückgegebene
Datenstruktur kann dann innerhalb des Plug-Ins beliebig manipuliert werden.
Wurden alle Daten erfolgreich manipuliert, können die Änderungen mit der {\em
save}-Methode gespeichert werden.

Die Registrierung eines Plug-Ins erfolgt durch die Antwort auf den vom Plug-In
System versendeten {\em Broadcast}, der nach der Installation einer neuen
Anwendung versendet wird. Um auf diesen {\em Broadcast} zu antworten, muss ein
{\em Broadcast Receiver} implementiert werden. Zu diesem Zweck existiert bereits
eine Implementierung des {\em Broadcast Receiver}, der {\em
AbstractPluginRegister}. Erbt man von dieser Klasse, muss man die {\em
onRegister}-Methode implementieren. Diese muss ein {\em PluginInfo}-Objekt
zurückliefern, welche die Plug-In Informationen enthält. Bei dem {\em
PluginInfo}-Objekt handelt es sich um ein Java \acs{pojo}, dass die in Abschnitt
\ref{pluginsystemforandroid} beschriebenen Attribute besitzt. Neben der reinen
Java Konfiguration kann man das Objekt auch aus einer \acs{xml}-Datei generieren
lassen. Dazu muss man von der {\em XMLPluginRegister}-Klasse erben und den Pfad
zur Konfigurationsdatei als Konstruktorparameter übergeben. Dabei muss darauf
geachtet werden, dass die Datei sich im {\em Java Classpath} befindet.

Damit das implementierte Plug-In und der {\em Broadcast Receiver} vom Android
System gefunden werden kann, müssen entsprechende Einträge in der {\em
AndroidManifest.xml} erfolgen.

Konkrete Beispiele zur Implementierung und Konfiguration sind dem Kapitel
\ref{cha:leitfaden} zu entnehmen.

\section{Architektur des Mobile Data Collectors}
Die Architektur des {\em Mobile Data Collector} ist in Abbildung
\ref{architecture} dargestellt. Wie in der Abbildung zu erkennen, stellt der
{\em Plug-In Service} (blau) die zentrale Komponente des {\em Mobile Data
Collector} dar. Er beherbergt das gesamte Plug-In System und kümmert sich somit
um die Verwaltung und Ausführung von Plug-Ins. Er speichert alle von den
Plug-Ins gesammelten Daten in einer \acs{db4o}-Datenbank (gelb). Sollte ein
Plug-In auf die Android System Services (grau) zugreifen, geschieht dies, aus
Transparenzgründen, ebenfalls über den Plug-In Service.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=13cm]{grafiken/architecture.png}
	\caption{Architektur des Mobile Data Collector}
	\label{architecture}
\end{figure}

Für die Benutzerinteraktion mit dem Plug-In Service stehen eine
Fülle von {\em Activities} (grün) zur Verfügung. Diese {\em Activities} sind:

\begin{itemize}
  \item Der {\bf Plug-In List} dient zur Auflistung von installierten Plug-Ins.
  \item Die {\bf Plug-In Details} erlaubt die Einsicht von Plug-In
  Informationen.
  \item Der {\bf Log-Viewer} dient zur Auflistung von Aufrufen von Android
  System Services.
  \item Der {\bf Data-Viewer} erlaubt die Betrachtung von allen vom Plug-In
  gesammelten Daten.
  \item Der {\bf Transfer-Manager} listet alle ausstehenden Übertragungen auf
  und erlaubt die nachträgliche Betrachtung aller bis zur Übertragung
  gesammelten Daten sowie deren Verwaltung.
\end{itemize}

Die Pfeile ausgehend vom und zum {\em Plug-In Service} stellen die
Aufrufrichtung dar. So ruft z.~B. der {\em Plug-In Service} immer die Plug-Ins
auf und die {\em Activities} den {\em Plug-In Service}.

Im Folgenden wird auf die zuvor beschriebenen Komponenten genauer eingegangen.

\subsection{Plug-In Service}
Der Plug-In Service stellt die zentrale Komponente zur Verwaltung von Plug-Ins
sowie deren Ausführung dar. Er beinhaltet die gesamte Applikationslogik des
{\em Mobile Data Collectors}. Alle {\em Activities} greifen über eine
entsprechende Schnittstelle auf diesen Service zu. Der {\em Plug-In Service} läuft
dabei dauerhaft im Hintergrund und führt die Plug-Ins in den vorgegebenen
Abständen aus.

Neben der Service-Schnittstelle stellt das {\em PluginConfiguration}-Objekt eine
wichtige Datenstruktur dar. Alle zusätzlichen Informationen über ein Plug-In,
die zur internen Verwaltung benötigt werden, werden im {\em
PluginConfiguration}-Objekt gespeichert. Dieses besitzt folgende Attribute:

\begin{itemize}
  \item {\bf Mode} gibt an, ob sich das Plug-In im {\em New}, {\em
  Activated}, {\em Deactivated} oder {\em Transfer} Zustand befindet. Im Letzteren
  werden die bisher gesammelten Daten für die Übertragung vorbereitet.
  \item {\bf State} gibt an ob, das Plug-In sich im {\em Resolved}, {\em
  Waiting} oder {\em Running} Zustand befindet. Im {\em Resolved} Zustand
  befindet es sich immer dann, wenn der {\em Mode} {\em New}, {\em Deactivated}
  oder {\em Transfer} ist. Zwischen den Zuständen {\em Waiting} und {\em Running}
  wechselt das Plug-In, wenn es sich im {\em Mode} {\em Activated} befindet.
  \item {\bf Last Executed} gibt an, wann das Plug-In das letzte Mal ausgeführt
  wurde.
  \item {\bf Last Activated} gibt an, wann das Plug-In das letzte Mal aktiviert
  wurde.
  \item {\bf Total Activation Time} gibt summiert an wielange das Plug-In
  aktiviert war.
  \item {\bf Permissions} gibt an, welche Zugriffsrechte das Plug-In vom Android
  Betriebssystem benötigt. Im besten Fall ist dieses Attribut leer, da
  dies bedeutet, dass das Plug-In nicht auf reglementierte Ressourcen zugreifen
  muss.
  \item {\bf Log Records} protokolliert alle Zugriffe, die auf die sicheren
  Versionen der Android System Services stattgefunden haben.
  \item {\bf Transfers} beinhaltet eine Liste von ausstehenden Übertragungen.
  \item {\bf Workspace} beinhaltet alle vom Plug-In gesammelten Daten. Dabei
  handelt es sich um ein {\em Node}-Objekt, an dem alle zusätzlichen Daten
  angehangen werden können.
\end{itemize}

Da die {\em PluginConfiguration} alle relevanten Plug-In Informationen, {\em
Log Records} und alle gesammelten Daten enthält, wird diese Datenstruktur 
zur Persistierung verwendet innerhalb der {\em db4o}-Datenbank.

\subsubsection{Service-Interface Definition}
Das Service-Interface beinhaltet die folgenden zentralen Methoden:

\begin{lstlisting}[language=java]
void addListener(PluginListener listener)
\end{lstlisting}

Erlaubt das Hinzufügen von {\em PluginListener}, die aufgerufen werden, wenn ein
neues Plug-In installiert bzw. entfernt wurde oder das Plug-In seinen {\em
Mode} oder {\em State} geändert hat.

\begin{lstlisting}[language=java]
void addListener(TransferListener listener)
\end{lstlisting}

Erlaubt das Hinzufügen von {\em TransferListener}, die aufgerufen werden, wenn
eine neue Übertragung erstellt bzw. entfernt wurde.

\begin{lstlisting}[language=java]
void activate(PluginConfiguration configuration)
\end{lstlisting}

Aktiviert das mit der übergebenen {\em PluginConfiguration} assoziierte Plug-In.

\begin{lstlisting}[language=java]
void deactivate(PluginConfiguration configuration)
\end{lstlisting}

Deaktiviert das mit der übergebenen {\em PluginConfiguration} assoziierte
Plug-In.

\begin{lstlisting}[language=java]
PluginConfiguration getPluginConfiguration(PluginInfo info)
\end{lstlisting}

Liefert die zur {\em PluginInfo} dazu gehörige {\em PluginConfiguration} zurück.
Existiert keine dazugehörige {\em PluginConfiguration}, so wird {\em null}
zurückgegeben.

\begin{lstlisting}[language=java]
List<PluginConfiguration> getPluginConfigurations()
\end{lstlisting}

Liefert alle installierten Plug-Ins zurück in Form von {\em
PluginConfiguration}-Objekten.

\begin{lstlisting}[language=java]
List<Transfer> getTransfers()
\end{lstlisting}

Liefert alle noch ausstehenden Übertragungen zurück. Sollten keine Übertragungen
vorhanden sein, wird eine leere Liste zurückgegeben.

\begin{lstlisting}[language=java]
void removeTransfer(Transfer transfer)
\end{lstlisting}

Entfernt den übergebenen Transfer. Diese Methode sollte normal nur dann
aufgerufen werden, wenn das {\em Transfer}-Objekt auch an einen externen Server
übertragen wurde.

\subsubsection{Plug-In Registierung}
Der Vorgang der Plug-In Registrierung ist in Abbildung \ref{register}
dargestellt.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=13cm]{grafiken/register.png}
	\caption{Plug-In Registierung}
	\label{register}
\end{figure}

Wie in dem Sequenzdiagramm zu erkennen, sendet als Erstes das Android System
einen {\em Broadcast} mit dem Inhalt, dass eine neue Anwendung installiert
wurde. Dieser wird vom {\em PackageAddedBroadcastReceiver} empfangen. Daraufhin
versendet dieser ein {\em Added-Intent} an den Plug-In Service, dass eine neue
Anwendung installiert wurde. Dieser {\em Intent} wird von der {\em
onStartCommand}-Methode des Services empfangen. Der Plug-In Service versendet
daraufhin ein {\em Find-Intent} an die neu installierte Anwendung. Antwortet die
Anwendung nicht, so handelt es sich nicht um ein Plug-In. Antwortet die
neu installierte Anwendung mit einem {\em PluginInfo}-Objekt, so handelt es sich
um ein neues Plug-In.  Das vom Plug-In System empfangene {\em PluginInfo}-Objekt
wird nun vom Plug-In Service in einem {\em PluginConfiguration}-Objekt
gespeichert. Das Plug-In gilt nun als registriert. Die weitere Verwaltung
des Plug-Ins findet über das {\em PluginConfiguration}-Objekt statt.

\subsubsection{Plug-In Ausführung}
Die Ausführung des Plug-Ins findet im {\em PluginTaskManager} statt. Diese
Klasse verwaltet alle aktivierten Plug-Ins und führt diese in dem vom Plug-In
vorgegeben Abstand aus. Dazu verwendet der {\em PluginTaskManager} einen
Thread-Pool, mit dem er eine bestimmte Anzahl von Plug-Ins parallel ausführen
kann. Zurzeit besitzt der Thread-Pool eine statische Größe von 1. Als
Thread-Pool Implementierung wurde der {\em ScheduledExecutorService} von der
Java Concurrency Bibliothek verwendet.

Wurde ein Plug-In aktiviert, wird dessen {\em PluginConfiguration}-Objekt an den
{\em PluginTaskManager} übergeben. Dieser kapselt das {\em
PluginConfiguration}-Objekt zu einem {\em PluginTask}-Objekt. Beim {\em
PluginTask} handelt es sich um ein ausführbares Objekt, dass das {\em
Runnable}-Interface implementiert. Dieser Task wird nun an den zuvor erwähnten
Thread-Pool zur sofortigen Ausführung übergeben. Bei der Ausführung wird aus der
{\em PluginInfo} die {\em Action} ausgelesen. Mit dieser ist es möglich, die
Service-Schnittstelle des Plug-Ins aufzurufen. Konnte eine Verbindung zum
Plug-In hergestellt werden, werden zuerst die in den Plug-In Informationen
angegebenen sicheren Android System Services sowie der {\em PersistenceManager}
gesetzt, um daraufhin das Plug-In auszuführen. Das Plug-In wird dabei nur
maximal für die im {\em PluginInfo} angegebene Zeit ausgeführt. Sollte diese
Zeit überschritten werden, so wird das Plug-In vom Android System terminiert.
Nach der Ausführung wird das Plug-In wieder zum Thread-Pool hinzugefügt, um ihn
aber diesmal erst nach dem vom Plug-In definierten Abstand auszuführen. Dies
wiederholt sich solange, bis das Plug-In deaktiviert wurde oder eine Übertragung
vorbereitet wird. Dadurch, dass das Plug-In immer im Nachhinein wieder zum
Thread-Pool hinzugefügt und nicht automatisch periodisch ausgeführt wird, wird
eine Überlappung der Plug-In Ausführungen verhindert.

Über den {\em PersistenceManager} können während der Ausführung beliebige
Informationen innerhalb der Datenbank des {\em Mobile Data Collectors}
gespeichert werden.

Sollte während der Ausführung ein Plug-In auf Methoden der sicheren Android
System Services zugreifen, so wird dieser Zugriff protokolliert. Dazu wird vor
jeder Ausführung ein neuer Eintrag zu den {\em Log Records} der {\em
PluginConfiguration} hinzugefügt. In einen solchen {\em Log Record} können nun
beliebig viele Einträge hinzugefügt werden, die den Zugriff in
menschenverständlicher Sprache protokollieren. Diese Einträge lassen sich dann
über den in Abschnitt \ref{plugin_details} beschriebenen {\em Log-Viewer}
einsehen.

\subsection{Plug-In List}
Die Plug-In List dient zur Auflistung aller installierten Plug-Ins. Sind keine
Plug-Ins installiert, wird wie in Abbildung \ref{pluginlist} zu sehen, der
Benutzer daraufhin gewiesen.

\begin{figure}[h!] \centering
	\includegraphics[width=5cm]{grafiken/pluginlist.png}
	\caption{Plug-In Viewer}
	\label{pluginlist}
\end{figure}

Neue Plug-Ins können über Eclipse, dem Android Market oder von der SD-Card
installiert werden. Um den Android Market schneller zu erreichen, kann auf
diesen wie in Abbildung \ref{more_plugins} über die Menütaste direkt zugegriffen
werden.

\begin{figure}[h!] \centering
	\includegraphics[width=5cm]{grafiken/more_plugins.png}
	\caption{Neue Plug-Ins installieren}
	\label{more_plugins}
\end{figure}

Wurden neue Plug-Ins installiert, werden diese wie in Abbildung \ref{plugins}
dargestellt im Plug-In Viewer angezeigt. Die installierten Plug-Ins befinden
sich zurzeit im Zustand {\em New}.

\begin{figure}[h!] \centering
	\includegraphics[width=5cm]{grafiken/plugins.png}
	\caption{Installierte Plug-Ins}
	\label{plugins}
\end{figure}

Durch das Anwählen eines Plug-Ins kann man dieses aktivieren. Bevor das Plug-In
aktiviert wird, werden wie in Abbildung \ref{activation} zu sehen, die Plug-In
Informationen angezeigt. Hat man alle Informationen kontrolliert und ist mit
diesen einverstanden, kann man durch das Drücken der {\em Activate} Schaltfläche
das Plug-In aktivieren. Durch das Drücken von {\em Cancel} kann man den
Aktivierungsprozess abbrechen.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/activation.png}
	\caption{Plug-In aktivierung}
	\label{activation}
\end{figure}

Hierbei ist besonders auf die sogenannten {\em Dangerous Permissions} zu achten.
Diese weisen den Benutzer daraufhin, dass das Plug-In auf Rechte zugreifen
möchte, die es normalerweise nicht braucht bzw. über diese, auf personenbezogene
Daten zugreifen könnte. Vor der Aktivierung wird deswegen der Benutzer durch die
in Abbildung \ref{activation_warning} dargestellte Warnung darüber informiert.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/activation_warning.png}
	\caption{Plug-In Aktivierung}
	\label{activation_warning}
\end{figure}

Ist sich der Benutzer trotzdem darüber bewusst, dass das Plug-In möglicherweise
gefährlich sein könnte, so kann er durch das Drücken der {\em OK} Schaltfläche
das Plug-In trotzdem aktivieren. Durch die {\em Cancel} Schaltfläche kann die
Aktivierung abgebrochen werden.

Nach der Aktivierung eines Plug-Ins, wechselt die Anzeige von {\em
New} zu {\em Activated}. Siehe Abbildung \ref{activate}, indem das
{\em Noise Tracker} Plug-In aktiviert wurde. Die Anzeige für Datum und
Uhrzeit zeigt an, wann das Plug-In zum letzten Mal ausgeführt wurde.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/active.png}
	\caption{Aktiviertes Plug-In}
	\label{activate}
\end{figure}

Wählt man ein aktiviertes Plug-In erneut an, deaktiviert man dieses, wie in
Abbildung \ref{deactivated} zu sehen.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/deactivated.png}
	\caption{Deaktiviertes Plug-In}
	\label{deactivated}
\end{figure}

Wählt man ein Plug-In durch ein langes Drücken aus, wird wie in Abbildung
\ref{plugin_context_menu} dargestellt, das Kontextmenü angezeigt. Dieses
erlaubt das Aktivieren und Deaktivieren eines Plug-Ins, das Anzeigen der Plug-In
Details (siehe hierzu Abschnitt \ref{plugin_details}), sowie das Deinstallieren
eines Plug-Ins.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/plugin_context_menu.png}
	\caption{Context-Menü eines Plug-Ins}
	\label{plugin_context_menu}
\end{figure}

\subsection{Plug-In Details}
\label{plugin_details}
Der Benutzer hat über die {\em Plug-In Details} die Möglichkeit, zu jedem
Zeitpunkt, alle Informationen und Aktivitäten eines Plug-Ins einzusehen. Die
{\em Plug-In Details} sind, wie im vorigen Abschnitt beschrieben, über das
Kontextmenü des Plug-Ins zu erreichen. Öffnet man die Details zu einem Plug-In,
werden die Plug-In Informationen, wie in Abbildung \ref{details}, angezeigt.
Über die Tabs im oberen Bildschirmbereich gelangt man zu den weiteren Bereichen
{\em Logs} und {\em Collected Data}, die in den folgenden Abschnitten {\em
Log-Viewer} und {\em Data-Viewer} genauer erläutert werden.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/details.png}
	\caption{Context-Menü eines Plug-Ins}
	\label{details}
\end{figure}

\subsubsection{Log-Viewer}
Der Log-Viewer dient zur Anzeige aller protokollierten Aktivitäten eines
Plug-Ins. Mit Aktivitäten ist der Zugriff auf die sicheren Android System Services gemeint.
Greift ein Plug-In auf eine Methode der Services zu, so wird ein Log-Eintrag
erstellt. Dieser enthält in benutzerverständlicher Sprache, welche Informationen
abgefragt wurden. Ein Beispiel ist in Abbildung \ref{log} dargestellt.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/log.png}
	\caption{Plug-In Logs}
	\label{log}
\end{figure}

Der Log ist dabei wie folgt aufgebaut. Jede Zeile zeigt an, wann das Plug-In
ausgeführt wurde. Durch die Auswahl eines Eintrags erweitern sich die Einträge
um die eigentlichen Log-Einträge. In diesem Fall sagen die Log-Einträge aus,
dass am 16.08.2011 um 5:58:40 Uhr das Plug-In ausgeführt wurde. Während dieser
Ausführung wurde zur Lokalisierung des Benutzers das GSM/UMTS Netz ({\em
network}) verwendet und als Position wurden die Koordinaten am 53.8477729
Längengrad und am 10.6977904 Breitengrad ermittelt.

\subsubsection{Data-Viewer}
Der Data-Viewer dient zur Anzeige aller vom Plug-In gesammelten Daten bzw. aller
Daten, die das Plug-In später übertragen möchte. Einem Plug-In steht es frei,
beliebig viele private Daten für interne Zwecke zu sammeln.

Die im Konzept beschriebene hierarchische Datenstruktur lässt sich durch den
Data-Viewer anzeigen. Dabei wird jede Ebene der Datenstruktur als Liste
dargestellt. In Abbildung \ref{collected_data_overview} wird die erste Ebene
angezeigt. Jeder anklickbare Knoten wird dabei als Datum angezeigt. Dieses
Datum gibt an, wann der entsprechende Datensatz das letzte Mal modifiziert
wurde. In diesem Fall werden drei Einträge dargestellt. In diesem Beispiel
überschneiden sich die Daten mit denen die im Log stehen. Damit ist gemeint,
dass nach jedem Zugriff auf den {\em LocationManager}, ein neuer Eintrag zu
den gesammelten Daten hinzugefügt wurde.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/collected_data_overview.png}
	\caption{Collected Data}
	\label{collected_data_overview}
\end{figure}

Wählt man einen Knoten aus, so gelangt man in der Hierarchie eine
Ebene tiefer. Die unterhalb eines Knoten gespeicherten Daten können wie in
Abbildung \ref{collected_data_details} aussehen. In diesem Beispiel befinden sich auf
der angezeigten Ebene nur Eigenschaften. Diese Eigenschaften beschreiben von
oben nach unten die Höhe, Geschwindigkeit, Lautstärke, Längengrad, Genauigkeit,
Breitengrad, Drehrichtung und die Art der Positionsbestimmung. Um wieder auf
eine höhere Ebene zu gelangen, kann die Zurücktaste verwendet werden.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/collected_data_details.png}
	\caption{Gesammelte Daten eines Plug-Ins}
	\label{collected_data_details}
\end{figure}

\subsection{Transfer-Manager}
Der Transfer-Manager dient zur Verwaltung aller ausstehenden Übertragungen.
Sollte eine neue Übertragung ausstehen, so wird der Benutzer wie in Abbildung
\ref{new_transfer} darüber informiert.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/new_transfer.png}
	\caption{Neue Übertragung}
	\label{new_transfer}
\end{figure}

Durch die Auswahl eines Eintrages gelangt der Benutzer in den
Übertragungsbereich des {\em Mobile Data Collectors}. Dieser kann bei einer
ausstehenden Übertragung wie in Abbildung \ref{transfer_pending} aussehen.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_pending.png}
	\caption{Ausstehende Übertragung}
	\label{transfer_pending}
\end{figure}

Wählt der Benutzer den entsprechenden Eintrag aus, so gelangt dieser in die, in
Abbildung \ref{transfer_details} dargestellte, Detailansicht der Übertragung. In
dieser kann der Benutzer noch mal alle Informationen und Aktivitäten des
Plug-Ins betrachten. Hierbei handelt es sich um einen Schnappschuss des aktuellen
Zustandes des Plug-Ins, den es hatte, als die Übertragung vorbereitet wurde.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_details.png}
	\caption{Übertragungsdetails}
	\label{transfer_details}
\end{figure}

Hat der Benutzer alle Daten gesichtet und ist mit der Übertragung einverstanden,
kann er durch das Drücken der {\em Transfer} Schaltfläche die Übertragung
einleiten. Daraufhin wird dem Benutzer der Fortschritt der Übertragung, wie in
Abbildung \ref{transfer_details_sending} und \ref{transfer_sending_notification}
zu sehen, als Dialog und Mitteilung angezeigt.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_details_sending.png}
	\caption{Übertragungsfortschritssdialog}
	\label{transfer_details_sending}
\end{figure}

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_sending_notification.png}
	\caption{Übertragungsfortschritt im Mitteilungsbereich}
	\label{transfer_sending_notification}
\end{figure}

Ist der Benutzer nicht mit der Übertragung seiner Daten einverstanden, kann er
durch die {\em Dismiss} Schaltfläche, die Übertragung löschen. Alle in der
Übertragung angezeigt Daten gehen daraufhin unwiderruflich verloren.

Intern wird bei der Übertragung zu einem Server eine \acs{http}-Verbindung
aufgebaut. Das Verbindungsziel wird hierbei dem \acs{url}-Attribut der Plug-In
Informationen entnommen. Die Daten, die in Form von Java-Objekten vorliegen, werden dann
mithilfe der GSON-Bibliothek in ein \acs{json}-Objekt übersetzt~\cite{gson}. Da
sich dabei nur um eine Zeichenkette handelt, kann dieser einfach per \acs{http} versendet
werden.

\section{Aufbau der Serverkomponente}
Durch die Serverkomponente soll ein Plug-In Entwickler die Möglichkeit erhalten,
sehr schnell und einfach einen eigenen Server zu implementieren, um Daten von
einem Plug-In zu empfangen und zu verarbeiten. Die Serverkomponente steht als
Java-Bibliothek bereit und soll die einfache Integration in bestehende
Applikationsserver erlauben.

Die Serverkomponente ist wie folgt aufgebaut. Das {\em
TransferRequestReceiver}-Servlet empfängt die vom {\em Mobile Data Collector}
versandte \acs{json}-Datenstruktur und konvertiert diese in eine äquivalente
Java-Datenstruktur. Zur Konvertierung wird wie auf dem Smartphone, die
GSON-Bibliothek verwendet. Diese Java-Datenstruktur kann nun vom {\em
TransferRequestProzessor} weiter verarbeitet werden. Es wird dabei empfohlen,
die sehr allgemeine empfangene Datenstruktur in eine spezifischere Datenstruktur
zu überführen, die sich leichter verarbeiten und speichern lässt. Wie die Daten
persistiert werden, muss der Entwickler selbst entscheiden.

Die Serverkomponente wurde dabei mithilfe des \acf{di}
Frameworks {\em Google Guice}~\cite{guice} und dem Java-Build-Werkzeug
{\em Maven}~\cite{maven} entwickelt.

Beispiele einschließlich deren Implementierung sind im Kapitel
\ref{cha:evaluation} genauer beschrieben.

\section{Realisierungsprobleme}
\label{problemsofimplementation}
Während der Realisierung des {\em Mobile Data Collectors} trat bei der 
Entwicklung folgendes Problem auf. Auf viele, der von Android verwalteten
Hardware kann zwischen mehreren parallel laufenden Anwendungen konkurrierend
zugegriffen werden. Diese Hardware wie z.~B. \acs{gps} oder der Lagesensor
werden aus diesen Gründen als System Service angeboten. Es gibt aber auch
Hardware, die nur von einer Anwendung zurzeit verwendet werden kann. Dies sind z.~B. die
Kamera und das Mikrofon. Diese werden nicht als System Service angeboten, sondern als
Schnittstelle zu einer nativen Bibliothek, die diese Hardware ansteuern kann.

System Services lassen sehr einfach durch eine neue Implementierung ersetzen.
Dies liegt daran, dass Android Services selbst zur Kommunikation mit der
eigentlichen dahinter liegenden Service Implementierung den
\acs{ipc}-Mechanismus verwenden. Dies ist bei den Klassen zur Ansteuerung der
Kamera und dem Mikrofon aber nicht der Fall. Das Problem liegt darin, dass die
Klassen zur Verwendung der Kamera und des Mikrofons, die Daten in Dateien
abspeichern. Man könnte nun diese Klassen wie die Services durch eine sichere
Implementierung ersetzen, indem man ebenfalls den \acs{ipc}-Mechanismus
verwendet, um die Ausführung in den {\em Mobile Data Collector} zu verschieben.
Hierbei ergibt sich aber nun das Problem, dass die aufgenommenen Daten in einer
Datei im {\em Mobile Data Collector} gespeichert werden. Diese Datei wäre für
ein Plug-In durch die Android Sandbox-Architektur nicht direkt zugreifbar.
Hierfür müsste eine weitere Schnittstelle geschaffen werden, um Plug-Ins den
Zugriff auf die Datei zu ermöglichen. Auf diese Lösung wurde zugunsten einer
einfacheren Implementierung von Plug-Ins verzichtet. Stattdessen sollte in
diesen Fällen die von Android zur Verfügung gestellten Implementierungen
verwendet werden. Da der Zugriff auf Kamera und Mikrofon ebenfalls durch {\em
Permissions} geregelt wird, wird bei Aktivierung der Benutzer darauf
hingewiesen. Da die eigentlichen zu übertragenden Daten aber weiterhin zentral
im {\em Mobile Data Collector} gespeichert werden müssen, entfällt hierbei nur
die Möglichkeit des Loggings.

Dieses Problem würde sich am besten durch die Verwendung von \acs{osgi} lösen
lassen. Durch \acs{osgi} würden der Mobile Data Collector und alle Plug-Ins im
selben Prozess laufen. Dadurch würde sich der Zugriff auf Dateien deutlich
vereinfachen. Des Weiteren könnte man durch einen eigenen {\em ClassLoader} den
Zugriff auf bestimmte Klassen verbieten, sodass ein Entwickler dazu gezwungen
wird, die sicheren Implementierungen einer Klasse zu verwenden.
