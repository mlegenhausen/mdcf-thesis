\chapter{Realisierung}
\label{cha:realisierung}
In diesem Kapitel wird die aus dem Konzept entwickelte Realisierung beschrieben.
Die Anwendung trägt dabei den Arbeitstitel {\em Mobile Data Collector}, während
das Framework zur Erstellung von Plug-Ins den Namen {\em Mobile Data Collection
Framework} trägt.

\section{Architektur des Mobile Data Collectors}
Der Mobile Data Collector ist in die folgenden Komponenten aufgeteilt:

\begin{itemize}
  \item Der {\bf Plug-In Service} ist der zentrale Service-Komponente für alle
  folgenden Activities. Er beherbergt das gesammte Plug-In System und kümmert
  sich somit um die Verwaltung und Ausführung von Plug-Ins.
  \item Der {\bf Plug-In Viewer} dient zur Auflistung von installierten Plug-Ins.
  \item Die {\bf Plug-In Details} erlauben die darstellung von Plug-In
  Informationen.
  \item Der {\bf Log-Viewer} dient zur Auflistung von Aufrufen von Android
  System Services.
  \item Der {\bf Data-Viewer} erlaubt die Betrachtung von allen vom Plug-In
  gesammelten Daten.
  \item Der {\bf Transfer-Manager} listet alle ausstehenden Übertragungen auf
  und erlaubt die nachträgliche Betrachtung aller bis zur Übertragung
  gesammelten Daten, sowie deren Verwaltung.
\end{itemize}

Der Plug-In Service stellt den eigentlichen {\em Mobile Data Collector} dar.
Über entsprechende Activities wie z.B. den Plug-In Viewer kann mit diesem
interagiert werden. Der Plug-In service läuft dabei dauerhaft im Hintergrund und
führt die Plug-Ins in den vorgebenen Abständen aus. Abbildung \ref{}
veranschautlich die Interaktion zwischen den einzelnen Komponenten.

ABBILDUNG hier hin!

Noch was zum Bild erzählen.

Der {\em Mobile Data Collector} wird als Open Source Projekt entwickelt und kann
auf Github unter der Adresse \url{https://github.com/mlegenhausen/mdcf} bezogen
werden. Das Projekt ist dabei in die folgenden Teile gegliedert:

\begin{itemize}
  \item {\bf MobileDataCollector}: Die {\em Mobile Data Collector} Android
  Anwendung.
  \item {\bf MobileDataCollectionFramework}: Das Framework zur Entwicklung von
  Plug-Ins.
  \item {\bf LocationTrackerPlugin}: Ein Beispiel Plug-In zum Sammeln von
  Standortdaten.
  \item {\bf NoiseTrackerPlugin}: Eine Erweiterung des {\em
  LoationTrackerPlugin} bei dem neben der aktuellen Position auch die Lautstärke
  gesammelt wird.
  \item {\bf mdcf-remote}: Framework zur Entwicklung der Serverkomponente.
  \item {\bf mdcf-locationtracker-remote}: Eine Beispielserverkomponente für
  das {\em LocationTrackerPlugin}.
  \item {\bf mdcf-noisetracker-remote}: Eine Beispielserverkomponente für das
  {\em NoiseTrackerPlugin}.
\end{itemize}

Im Folgenden wird auf die zurvor beschriebenen Komponenten genauer eingegangen.

\subsection{Plug-In Service}
Der Plug-In Service stellt die zentrale Komponente zur Verwaltung von Plug-Ins,
sowie deren Ausführung dar. Er beinhaltet die gesammte Applikationslogik des
{\em Mobile Data Collectors}. Alle Activities greifen über eine entsprechende
Service Schnittstelle auf diesen Service zu.

Das Service-Interface beinhaltet die folgenden zentralen Methoden:

\begin{itemize}
  \item activate
  \item deactivate
\end{itemize}

Alle Informationen die über ein Plug-In, die nicht im {PluginInfo}-Objekt
enthalten sind werden im {\em PluginConfiguration}-Objekt gespeichert. Alle
zusätzlichen Informationen sind im folgenden aufgelistet.

\begin{itemize}
  \item {\em Mode} gibt an ob, das Plug-In {\em New}, {\em Activated},
  {\em Deactivated} oder sich im {\em Transfer} Zustand befindet. Im letzteren
  werden die bisher gesammelten Daten für die Übertragung vorbereitet.
  \item {\em State} gibt an ob, das Plug-In sich im {\em Resolved}, {\em
  Waiting} oder {\em Running} Zustand befindet. Im {\em Resolved} Zustand
  befindet es sich immer, wenn der {\em Mode} {\em New}, {\em Deactivated} oder
  {\em Transfer} ist. Zwischen den Zuständen {\em Waiting} und {\em Running}
  wechselt das Plug-In wenn es sich im {\em Mode} {\em Activated} befindet.
  \item {\em Last Executed} gibt an, wann das Plug-In das letzte mal ausgeführt
  wurde.
  \item {\em Last Activated} gibt an, wann das Plug-In das letzte mal aktiviert
  wurde.
  \item {\em Total Activation Time} gibt summiert an, wielange das Plug-In
  activiert war.
  \item {\em Permissions} gibt an, welche Zugriffsrechte das Plug-In vom Android
  Betriebssystem benötigt. Dieses Attribut sollte im besten Fall leer sein. So
  das alle aktionen über den Mobile Data Collector geschehen können.
  \item {\em Log Records} speichert alle Zugriffe die auf die sicheren Versionen
  der Android System Services stattgefunden haben.
  \item {\em Transfers} beinhaltet eine Liste von ausstehenden Übertragungen.
  \item {\em Workspace} beinhaltet alle vom Plug-In gesammelten Daten. Dabie
  handelt es sich um ein {\em Node}-Objekt an dem alle zusätzlichen Daten
  gespeichert werden können.
\end{itemize}

\subsubsection{Plug-In Registierung}
Der Vorgang der Plug-In Registierung ist in Abbildung \ref{} genauer
dargestellt.

Sendet das Android System einen {\em Broadcast}, dass eine neue Anwendung
installiert wurde, so wird dieses vom {\em PackageAddedBroadcastReceiver}
empfangen. Daraufhin versendet dieser ein {\em Intent} an den Plug-In Service
das eine neue Anwendung installiert wurde. Dieser {\em Intent} wird von der
{\em onStartCommand}-Methode des Services empfangen. Der Plug-In Service
versendet daraufhin ein {\em Intent} an die neu installierte Anwendung.
Antwortet die neuinstallierte Anwendung mit einem {\em PluginInfo}-Objekt, so
handelt es sich um ein neues Plug-In. Antwortet die Anwendung nicht, so handelt
es sich nicht um ein Plug-In. Das vom Plug-In empfangene {\em PluginInfo}-Objekt
wird nun vom Plug-In Service in einem {\em PluginConfiguration}-Objekt
gespeichert. Die weitere Verwaltung des Plug-Ins findet über das {\em
PluginConfiguration}-Objekt statt.

\subsubsection{Plug-In Ausführung}
Die Ausführung des Plug-Ins findet im {\em PluginTaskManager} statt. Diese
Klasse verwaltet alle aktivierten Plug-Ins und führt diese in dem vom Plug-In
vorgegeben Abstand aus. Dazu verwaltet der {\em PluginTaskManager} einen
Thread-Pool mit dem er eine bestimmte Anzahl von Plug-Ins parallel ausführen
kann. Als Thread-Pool implementierung für Java, wurde der {\em
ScheduledExecutorService} von der Java Concurrency Bibliothek verwendet.

Wurde ein Plug-In aktiviert, wird dessen {\em PluginConfiguration}-Objekt an den
{\em PluginTaskManager} übergeben. Dieser kapselt das Objekt zu einen {\em
PluginTask}. Beim {\em PluginTask} handelt es sich um ein ausführbares Objekt,
dass das {\em Runnable} Interface implementiert. Dieser Task wird nun an den
zuvor erwähnten Thread-Pool übergeben. Dieser führt daraufhin das Plug-In mit
dem vom Plug-In definierten Abstand einmalig aus. Wird das Plug-In ausgeführt
wird aus der {\em PluginInfo} die {\em Action} ausgelesen. Mit dieser ist es
Möglich die Service Schnittstelle des Plug-Ins aufzurufen. Konnte eine
Verbindung zum Plug-In hergestellt werden, werden zuerst alle für die Ausführung
nötigen Objekte übergeben und dann das Plug-In ausgeführt. Das Plug-In wird
dabei nur für die im {\em PluginInfo} angegebene Zeit ausgeführt. Sollte die
Zeit überschritten werden, so wird dieses vom Android System terminiert. Nach
der Ausführung wird das Plug-In wieder mit dem zuvor definierten Abstand zum
Thread-Pool hinzugefügt. Dadurch, das dass Plug-In immer im nachhinein wieder
zum Thread-Pool hinzugefügt und nicht automatisch periodisch ausgeführt wird,
verhindert eine Überlappung der Plug-In Ausführungen.

Sollte ein Plug-In deaktiviert werden, wird es vom {\em PluginTaskManager} aus
dem Thread-Pool entfernt.

\subsection{Plug-In Viewer}
Der Plug-In Viewer dient zur Auflistung aller installierten Plug-Ins. Sind keine
Plug-Ins installiert, wird wie in Abbildung \ref{pluginlist} zu sehen, der
Benutzer daraufhin gewiesen.

\begin{figure}[h!] \centering
	\includegraphics[width=5cm]{grafiken/pluginlist.png}
	\caption{Plug-In Viewer}
	\label{pluginlist}
\end{figure}

Neue Plug-Ins können über Eclipse, dem Android Market oder von der SD-Card installert werden. Um den
Android Market schneller zu erreichen kann wie in Abbildung \ref{more_plugins}
direkt über den {\em Mobile Data Collector} durch einen Druck auf die
hardwareseitige {\em Menü}-Taste zugegriffen werden.

\begin{figure}[h!] \centering
	\includegraphics[width=5cm]{grafiken/more_plugins.png}
	\caption{Neue Plug-Ins installieren}
	\label{more_plugins}
\end{figure}

Wurden neue Plug-Ins installiert, werden diese wie in Abbildung \ref{plugins}
dargestellt im Plug-In Viewer angezeigt. Die installierten Plug-Ins befinden
sich zurzeit im Zustand {\em New}.

\begin{figure}[h!] \centering
	\includegraphics[width=5cm]{grafiken/plugins.png}
	\caption{Installierte Plug-Ins}
	\label{plugins}
\end{figure}

Durch das anwählen eines Plug-Ins kann man dieses aktivieren. Bevor das Plug-In
aktiviert wird, werden wie in Abbildung \ref{activation} zu sehen, die Plug-In
Informationen angezeigt. Hat man alle Informationen kontrolliert und ist mit der
Ausführung einverstanden, kann man durch drücken der {\em Activate}
Schaltfläche das Plug-In aktivieren. Durch das drücken von {\em Cancel} kann man
die Aktivierug wieder verlassen.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/activation.png}
	\caption{Plug-In aktivierung}
	\label{activation}
\end{figure}

Hierbei ist besonders auf die sogenannten {\em Dangerous Permissions} zu achten.
Diese weisen den Benutzer darauf hin, dass das Plug-In auf Rechte zugreifen
möchte, die es normalerweise nicht braucht bzw. über diese auf personenbezogene
Daten zugreifen könnte. Vor der Aktivierung wird deswegen der Benutzer durch die
in Abbildung \ref{activation_warning} dargestellte Warnung darüber informiert.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/activation_warning.png}
	\caption{Plug-In aktivierung}
	\label{activation_warning}
\end{figure}

Ist sich der Benutzer trotzdem darüber bewusst, dass das Plug-In möglicherweise
gefährlich sein könnte, so kann er durch drücken der {\em OK} Schaltfläche das
Plug-In trotzdem aktivieren. Durch die {\em Cancel} Schaltfläche kann die
Aktivierung entsprechend abgebrochen werden.

Nach der Aktivierug eines Plug-In wechselt entsprechend die Anzeige von {\em
New} zu {\em Activated}. Siehe Abbildung \ref{activate}, wo in diesem Fall das
{\em Noise Tracker} Plug-In aktiviert wurde. Die Anzeige für Datum und
Uhrzeit zeigt an, wann das Plug-In zum letzten mal ausgeführt wurde.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/active.png}
	\caption{Aktiviertes Plug-In}
	\label{activate}
\end{figure}

Wählt man ein aktiviertes Plug-In erneut an, deaktiviert man dieses, wie in
Abbildung \ref{deactivated} zu sehen.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/deactivated.png}
	\caption{Deaktiviertes Plug-In}
	\label{deactivated}
\end{figure}

Wählt man ein Plug-In durch ein langes drücken aus, wird wie in Abbildung
\ref{plugin_context_menu} dargestellt, das Context-Menü angezeigt. Dieses
erlaubt das aktivieren und deaktivieren eines Plug-Ins, das anzeigen der Plug-In
Details (Siehe hierzu Abschnitt \ref{plugin_details}), sowie das deinstallieren
eines Plug-Ins.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/plugin_context_menu.png}
	\caption{Context-Menü eines Plug-Ins}
	\label{plugin_context_menu}
\end{figure}

\subsection{Plug-In Details}
\label{plugin_details}
Der Benutzer hat über die Plug-In Details zu jedem Zeitpunkt die Möglichkeit
alle Informationen und Aktivitäten eines Plug-Ins sich anzeigen zu lassen. Die
Plug-In Details sind, wie im vorigen Abschnitt beschrieben, über das
Context-Menu des Plug-Ins zu erreichen. Öffnet man die Details zu einem Plug-In
werden wie in Abbildung \ref{details} dargestellt, die Plug-In Informationen
angezeigt. Über die Tabs im oberen Bildschirmbereich gelangt man, zu den
weiteren Bereichen {\em Logs} und {\em Collected Data}, die in den folgenden
Abschnitten {\em Log-Viewer} und {\em Data-Viewer} genauer erläutert werden.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/details.png}
	\caption{Context-Menü eines Plug-Ins}
	\label{details}
\end{figure}

\subsubsection{Log-Viewer}
Der Log-Viewer dient zur Anzeige, aller Aktivitäten eines Plug-Ins. Mit
Aktivitäten ist der Zugriff auf alle Android System Services gemeint. Greift ein
Plug-In auf eine Methode der System Services zu, so wird ein Log eintrag
erstellt. Dieser enthält in benutzerverständlicher Sprache, welche Informationen
abgefragt wurden. Ein Beispiel ist in Abbildung \ref{log} dargestellt.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/log.png}
	\caption{Plug-In Logs}
	\label{log}
\end{figure}

Der Log ist dabei wie folgt aufgebaut. Jede Zeile zeigt an, wann das Plug-In
ausgeführt wurde. Durch die Auswahl eines Eintrags erweitern sich die Einträge
um die eigendlichen Log einträge. In diesem Fall sagen die Log Einträge aus, das
am 16.08.2011 um 5:58:40 Uhr das Plug-In ausgeführt wurde. Während dieser
Ausführung wurde zur Lokalisierung des Benutzers das GSM/UMTS Netz ({\em
network}) verwendet und als Position wurden die Koordinaten am 53,8477729
Längengrad und am 10.6977904 Breitengrad ermittelt.

\subsubsection{Data-Viewer}
Der Data-Viewer dient zur Anzeige aller vom Plug-In gesammelten Daten bzw. aller
Daten, die das Plug-In später Übertragen möchte. Einem Plug-In steht es frei
beliebig viele private Daten für interne Zwecke zu Sammeln.

Die im Konzept beschriebene hierarchische Datenstruktur lässt sich durch den
Data-Viewer anzeigen. Dabei wird jede Ebene der Datenstruktur als Liste
dargestellt. In Abbildung \ref{collected_data_overview} wird die erste Ebene
angezeigt. Jede anklickbare {\em Node} wird dabei als Datum angezeigt. Dieses
Datum gibt an, wann der entsprechende Datensatz das letzte mal modifiziert
wurde. In diesem Fall werden drei Einträge dargestellt. In diesem Beispiel
überschneiden sich die Daten mit denen die im Log stehen. Es wurde also bei
jeder Ausführung jeweils ein neuer Eintrag zu den gesammelten Daten hinzugefügt.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/collected_data_overview.png}
	\caption{Plug-In Logs}
	\label{collected_data_overview}
\end{figure}

Wählt man einen {\em Node}-Eintrag aus, so gelangt man in der hierarchie eine
Ebene tiefer. Die sich dabei ergebenen Daten können wie in Abbildung
\ref{collected_data_details} aussehen. In diesem Beispiel befinden sich auf
dieser Ebene nur {\em Properties}. Diese {\em Properties} beschreiben von oben
nach unten die Höhe, Geschwindigkeit, Lautstärke, Längengrad, Genauigkeit,
Breitengrad, Drehrichtung, Art der Positionsbestimmung. Um wieder auf eine
höhere Ebene zu gelangen, kann die hardwareseitige Zurücktaste verwendet werden.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/collected_data_details.png}
	\caption{Gesammelte Daten eines Plug-Ins}
	\label{collected_data_details}
\end{figure}

\subsection{Transfer-Manager}
Der Transfer-Manager dient zur Verwaltung aller ausstehenden Übertragungen.
Sollte eine neue Übertragung ausstehen, so wird der Benutzer wie in Abbildung
\ref{new_transfer} darüber informiert.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/new_transfer.png}
	\caption{Neue Übertragung}
	\label{new_transfer}
\end{figure}

Durch die Auswahl des Eintrages gelangt der Benutzer in den Übertragungsbereich
des {\em Mobile Data Collectors}. Dieser kann bei einer ausstehenden Übertragung
wie in Abbildung \ref{transfer_pending} aussehen.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_pending.png}
	\caption{Ausstehende Übertragung}
	\label{transfer_pending}
\end{figure}

Wählt der Benutzer den entsprechenden Eintrag aus, so gelangt dieser in die, in
Abbildung \ref{transfer_details} dargestellte, Detailansicht der Übertragung. In
dieser kann der Benutzer nochmal alle Informationen und Aktivitäten des Plug-Ins
betrachten. Hierbei handelt es sich um einen Schnapschuss des aktuellen
Zustandes des Plug-Ins, den es hatte, als die Übertragung vorbereitet wurde.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_details.png}
	\caption{Übertragungsdetails}
	\label{transfer_details}
\end{figure}

Hat der Benutzer alle Daten gesichtet und ist mit der Übertragung einverstanden,
kann er durch drücken der {\em Transfer} Schaltfläche die Übertragung einleiten.
Daraufhin wird dem Benutzer der Fortschritt der Übertragung wie in Abbildung
\ref{transfer_details_sending} und \ref{transfer_sending_notification} zu sehen
als Dialog und Mitteilung angezeigt.

\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_details_sending.png}
	\caption{Übertragungsfortschritssdialog}
	\label{transfer_details_sending}
\end{figure}
\begin{figure}[h!] 
	\centering
	\includegraphics[width=5cm]{grafiken/transfer_sending_notification.png}
	\caption{Übertragungsfortschritt im Mitteilungsbereich}
	\label{transfer_sending_notification}
\end{figure}

Ist der Benutzer nicht mit der Übertragung seiner Daten einverstanden, kann er
durch die {\em Dismiss} Schaltfläche, die Übertragung löschen.

\section{Aufbau und Verwendung des Mobile Data Collection Frameworks}
Das {\em Mobile Data Collection Framework} dient zur Erstellung von Plug-Ins. Es
beinhaltet alle Klassen und Interfaces die zwischen dem {\em Mobile Data
Collector} und dem Plug-In geteilt werden, um eine Kommunikation zwischen beiden
Komponenten zu ermöglichen. Das Framework wird als Android Bibliothek zur
Verfügunng gestellt.

Das Framework ist in drei Teile gegliedert. Zum einen Klassen und
Interfaces, die es einem Plug-In erlauben sich an dem Plug-In System anzumelden
und mit diesem über Schnittstellen zu kommunizieren. Zum anderen einer
Implementierung der in Abschnitt \ref{unifiedrepresentation} beschriebenen
Datenstruktur. Der letzte Teil beinhaltet die Schnittstellen der in Abschnitt
\ref{securepluginexecution} beschriebenen sicheren Android Services.

Ein Plug-In wird dadurch definiert, dass die {\em Plugin}
Schnittstelle implementiert wird. Diese stellt alle für das Plug-In System
nötigen Methoden zur Verfügung, um mit dem Plug-In zu interagieren. Die
Schnittstelle selbst besteht aus einer Reihe von {\em Settern} mit denen die
sicheren Versionen der Android System Services und ein {\em
PersistenceManager} gesetzt werden, sowie einer {\em run}-Methode mit der
das Plug-In ausgeführt wird. Da die {\em Setter} implementierung trivial und in
den meisten Fällen identisch sind, gibt es zur Vereinfachung die Klasse {\em
AbstractPlugin}. Erbt man von dieser Klasse muss nur noch die {\em run}-Methode
implementiert werden.

Innerhalb der {\em run}-Methode kann auf die gesetzten Services zugegriffen
werden. Die Services bieten alle in der Android Dokumentation beschriebenen
Methoden. Neben den Services kann auch auf einen {\em PersistenceManager}
zugegriffen werden. Dieser erlaubt das einfache Abfragen aller bisher
gespeicherter Daten über die {\em getWorkspace}-Methode. Die zurückgebene
Datenstruktur kann dann innerhalb des Plug-Ins beliebig manipuliert werden.
Wurden alle Daten erfolgreich manipuliert, kann über die {\em save}-Methode die
Speicherung der Änderungen erfolgen.

Damit das Plug-In System das Plug-In auffinden kann, muss das Plug-In einen
{\em Broadcast Receiver} implementieren, der den vom Plug-In System versandten
Broadcast empfangen kann und mit den Plug-In Informationen antwortet. Zu diesem
Zweck existiert das {\em AbstractPluginRegister}. Erbt man von dieser Klasse
muss man die {\em onRegister}-Methode implementieren. Diese muss ein {\em
PluginInfo}-Objekt zurück liefern, welche die Plug-In Informationen enthält. Bei
dem {\em PluginInfo}-Objekt handelt es sich um ein Java POJO. Neben der reinen
Java Konfiguration kann man das Objekt auch aus einer XML-Datei generieren
lassen. Dazu muss man von der {\em XMLPluginRegister} Klasse erben und den Pfad
zur Konfigurationsdatei als Konstrukturparameter übergeben. Dabei muss darauf
geachtet werden, dass die Datei sich im {\em Java Classpath} befindet.

Damit das implementierte Plug-In und der {\em Broadcast Receiver} vom Android
System gefunden werden können, müssen entsprechende Einträge in der {\em
AndroidManifest.xml} erfolgen.

Konkrete Beispiele sind dem Kapitel \ref{cha:leitfaden} zu entnehmen.

\section{Aufbau der Serverkomponente}
Durch die Serverkomponente soll ein Plug-In Entwickler die Möglichkeit erhalten,
sehr schnell und einfach einen eigenen Server zu entwickeln um Daten von
einem Plug-In zu empfangen und zu verarbeiten. Die Serverkomponente steht als
Java Bibliothek bereit und soll die einfache integration in bestehende
Applikationsserver erlauben.

Die Serverkomponente ist wie folgt aufgebaut. Das {\em TransferRequestReceiver
Servlet} empängt die vom {\em Mobile Data Collector} versandte JSON
Datenstruktur und konvertiert diese in eine äquivalente Java Datenstruktur. Zur
Konvertierung wurde wie auf der Smartphone Seite die GSON Bibliothek verwendet.
Diese Java Datenstruktur kann nun vom {\em TransferRequestProzessor} weiter
verarbeitet werden. Es wird dabei empfohlen, die sehr allgemeine empfangene
Datenstruktur in eine spezifischere Datenstruktur zu überführen, die sich
leichter verarbeiten und speichern lässt. Wie die Daten persistiert werden muss
der Entwickler selbst entscheiden.

Die Serverkompoente wurde dabei mit Hilfe des {\em Dependency Injection}
Frameworks {\em Google Guice} und dem Java-Build-Werkzeug Maven entwickelt.

Beispiele einschließlicher deren Implementierung sind im Kapitel
\ref{cha:evaluation} genauer beschrieben.

\section{Realisierungsprobleme}
Während der Realisierung des {\em Mobile Data Collectors} tratt bei der Plug-In
Entwicklung folgendes Problem auf. Viele der von Android verwalteten Hardware
kann zwischen mehren parallel laufenden Anwendungen konkurrierend zugegriffen
werden. Diese Hardware wie z.B. GPS wird aus diesen Gründen als System Service
angeboten. Es gibt aber auch Hardware die nur von einer Anwendung zurzeit
verwendet werden kann. Dies sind z.B. die Kamera und das Mikrofon. Diese werden
nicht als System Service angeboten sondern als Schnittstelle zu einer
nativen Bibliothek, die diese Hardware ansteuern kann.

Das Problem besteht nun darin, dass sich System Services sehr einfach durch eine
neue implementierung ersetzen lassen. Dies liegt daran, dass Android Services
selbst zur Kommunikation mit der eigentlichen dahinter liegende Service
Implementierung den IPC Mechanimus verwenden. Dies ist bei den Klassen zur
Ansteuerung der Kamera und dem Mikrofon aber nicht der Fall. Das Problem liegt
darin, dass die Klassen zur Verwendung der Kamera und des Mikrofons die Daten in
Dateien abspeichern. Man könnte nun diese Klassen wie die Services durch eine
sichere Implementierung ersetzen, indem man ebenfalls den IPC Mechanimus
verwendet, um die Ausführung in den {\em Mobile Data Collector} zu verschieben.
Hierbei ergibt sich aber nun das Problem, dass die aufgenommen Daten im {\em
Mobile Data Collector} gespeichert werden. Diese Daten wären für ein
Plug-In durch die Android Sandbox Architektur nicht direkt zugreifbar. Hierfür
müsste wieder eine weitere Schnittstelle geschaffen werden, um die Daten den
Plug-Ins zugreifbar zu machen.

Auf diese Lösuung wurde zu Gunsten einer einfacheren Implementierung von
Plug-Ins verzichtet. Stattdessen sollte in diesen Fällen die von Android zur
Verfügung gestellten Implementierungen verwendet werden. Da der Zugriff
auf Kamera und Mikrofon ebenfalls durch Permissions geregelt wird, wird bei
Aktivierung der Benutzer darauf hingewiesen. Da die eigentlichen zu
übertragenden Daten aber weiterhin zentral im Mobile Data Collector gespeichert
werden, entfällt hierbei nur die Möglichkeit des Loggings.

Dieses Problem würde sich am besten durch die Verwendung von OSGi lösen lassen.
Durch OSGi würden der Mobile Data Collector und alle Plug-Ins im
selben Prozess laufen. Dadurch würde sich der Zugriff auf Dateien deutlich
vereinfachen. Des Weiteren könnte man durch einen eigenen {\em ClassLoader} den
Zugriff auf bestimmte Klassen verbieten, so das ein Entwickler dazu gezwungen
wird die sicheren Implementierungen einer Klasse zu verwenden.
